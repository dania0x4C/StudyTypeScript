//타입스크립트는 컴파일을 하면 javascript 코드가 되는 언어이다.

import { AgentArn } from "aws-sdk/clients/datasync";

let a ="hello"
// a = 1 typescript에서 값을 추론해서 다른 변수의 값으로 전환이 안 되게 만들었다

let b : number = 1;
let c : boolean = true;
let d : string = "li";
// :type 이 방식은 직접적으로 변수형을 알려주는 typescript의 방식이다(TypeChecker)

//배열의 타입을 선언
let list = []

let e : number[] = [1, 2];
let f : boolean[] = [true, false];
let g : string[] = ["li" ,"ul"];

//최대한 typescript가 추론하게 만드는 방식이 더 좋다

const player1 = {
    name: "jungmin"
}

player1.name = "only String"

// object에 타입 설정하기
const player2 : {
    name: string,
    age?: number
} = {
    name: "jungmin",
}
//기본 상태로 작성하면 require상태이지만 ?를 사용해서 선언하면 age의 경우 number or undefined상태가 된다

// if(player2.age < 20){} 이 코드가 안 되는 이유는 undefined 상태일 수 있기 때문이다.
// if(player2.age < 20 && player2.age){} 이 코드가 안 되는 이유는 &&의 작동 방식이 앞의 값이 true이어야 뒤에 값으로 넘어가기 때문인거 같다

if(player2.age && player2.age < 20){}

//위의 방식은 번거롭기 때문에 다음의 Alias도 가능하다
type Age = number

type Player = {
    readonly name: string,
    age?: Age
}

const player3 : Player = {
    name: "jungmin",
}

function playerMaker1(name:string) : Player {
    return {
        name: name
    }
}

//함수로는 name만 받을 것이고 함수가 리턴하는 값을 지정해 주는 방식도 다른 변수 설정 방식가 똑같다.

const player4 = playerMaker1("jj")

player4.age = 12
// 이 값도 사실 Player형으로 지정하지 않으면 오류가 생기지만 Player형으로 해주면서 오류가 사라진다

function playerMaker2(name:string){
    return {
        name: name
    }
}

const player5 = playerMaker2("jj")
//player5.age 오류가 생긴다

//화살표 함수
const playerMaker3 = (name:string) : Player => ({
    name:name
})

const player6 = playerMaker1("jungminLee")
player6.age = 20

// player6.name = "k"
// readonly는 값을 선언하고 바꾸지 못하게 만든다
// list에 사용하면 값이 push 되지 않는다.
//즉, 가변성을 부여한다고 생각하면 된다

const player7: [string, number, boolean] = ["nico", 1, true]// Tuple

// 이 코드는 readonly도 사용 가능

let h : undefined = undefined
let i : null = null

//any는 typeScript에서 빠져나가고 싶을때 사용하는 방법이다.

const arr: any[] = [1,2,3,4]
const bool: any = true

arr+bool// 그래서 말도 안 되는 연산이 가능해졌다

// unknown은 어느 타입이든 할당이 가능하다.
let value: unknown = 'type';
value = 10;
value = true;

// 하지만 타입 체크를 하지 않으면 컴파일러 오류가 생겨서 사용이 불가능하다
if(typeof value === "string") {
    console.log(value)
}

// console.log(value) 사용 불가능

//void는 함수에서 반환 값이 없다는 것을 표현 할 때 사용하는 것
function voidPrac(param: string): void {
    console.log(param);
}

//never

// 이 함수는 결코 정상적으로 종료되지 않습니다.
function error(message: string): never {
    throw new Error(message); // 예외를 발생시키고 종료됩니다.
  }
  
  function infiniteLoop(): never {
    while (true) {
      // 무한 루프로 인해 함수가 결코 종료되지 않습니다.
    }
  }

  // 필요성
  // 코드의 특정 부분이 실행되지 않도록 설계된 경우에 타입 안정성을 보장하는 데 매우 중요하다.
  // 즉, 예상치 못 한 값이나 상태에 대한 처리를 따로 할 필요가 없다.
  